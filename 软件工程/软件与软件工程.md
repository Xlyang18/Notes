# 软件与软件工程



## 1.1 软件

### 1.1.1 软件的概念与特征

- **软件的定义**
  - 软件是程序和所以使程序正确运行所需要的相关文档和配置信息
  - Software = Program + Data + Document

- 软件的特征
  1. 软件是无形的
  2. 软件副本制作简单
  3. 软件无磨损

### 1.1.2 软件的发展

| 阶段     | 第一阶段                             | 第二阶段                             | 第三阶段                                                 | 第四阶段                                                     |
| :------- | :----------------------------------- | :----------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 典型技术 | 面向批处理<br>有限分布<br>自定义软件 | 多用户<br>实时<br>数据库<br>软件产品 | 分布式系统<br>嵌入“智能能”<br>低成本硬件<br>消费者的影响 | 强大的桌面系统<br>面向对对象技术<br>专家系统<br>人工神经网络<br>并行计算<br>网络计算机 |

### 1.1.3 软件分类

- 基于软件的功能
  - 系统软件、支撑软件、应用软件
- 基于软件工作方式的划分
  - 实时处理软件、分时软件、交互式软件、批处理软件
- 基于软件规模的划分
  - 微型软件、小型软件、中型软件、大型软件、巨大型软件、极大型软件
- 基于软件失效的影响进行划分
- 基于软件服务对象的范围进行划分
  - 定制软件、产品软件

***



## 1.2 软件危机

### 1.2.1 具体表现

- 软件危机：软件开发和维护过程中遇到的一系列严重问题
- 具体表现：
  - 产品不符合用户的实际需要；
  -  软件开发生产率不高，不能满足客观需要；
  -  软件产品质量差；
  - 对软件开发成本和进度的估计不准确；
  - 可维护性差；
  - 软件的文档资料不完整和不合格；
  -  软件成本逐年上升。

### 1.2.2 产生原因（宏观）

1. 缺乏总体考虑，没有软件工程学概念或系统工程思想。--**软件**
2. 对业务了解支离破碎，需求分析不准。--**软件**
3. 企业依赖激情指挥，企业管理标准化、规范化、科学化程度不高，导致不能成功地应用 “死板”的软件，它依赖于业务的“科学化”、“条理化”、“程序化” --**企业**
4. 缺乏总体考虑，没有软件工程学概念或系统工程思想。--**软件**
5. 对业务了解支离破碎，需求分析不准。--**软件**
6. 企业依赖激情指挥，企业管理标准化、规范化、科学化程度不高，导致不能成功地应用 “死板”的软件，它依赖于业务的“科学化”、“条理化”、“程序化” --**企业**

### 1.2.3 产生的原因（微观）

1. 软件的规模比较庞大，其开发和维护相当困难；
1. 开发人员虽然有经验，但还存在着不少错误观点，没有实行工程化的方法；
1. 不能与用户及时沟通，不能了解用户的实际需要；
1. 没有统一的软件质量管理规范；
1. 不能根据环境的变化而随时对产品进行改正。

***



## 1.3 软件工程

### 1.3.1 软件工程概念

- 中心思想：
  - 把软件当作一种工业产品，要求采用工程化的原理与方法对软件进行计划、开发和维护。
- 目的：
  - 实现按预期的进度和经费完成软件生产计划，提高软件的生产率和可靠性。

### 1.3.2 软件工程基本流程

- 软件开发工程化：
  - **按近代科学及产业形成的一套工程化方法和思想办事。**

1. 首先进行系统调查和系统分析
2. 再进行逻辑设计、物理设计;
3. 最后才编制实施；
4. 反复测试;
5. 试运行后，再投入长期运行;
6. 在运行中不断维护、完善。

- 按工程化方法开发，把手工、个体化的脑力劳动方式转变成集体性的有严格分工的脑力劳动，运用先进的软件开发工具，提高开发效率。

### 1.3.3 入那件开发的原则

1. 分解
2. 信息隐蔽
3. 模块化
4. 标准化

***



## 1.4 软件生命周期

### 1.4.1 软件生命周期概念

任何有生命的动物、植物和人，都有一个生存周期(Life Cycle)，例如人的生存周期为胎儿、婴儿、幼儿、儿童、少年、青年、中年、老年、死亡。

没有生命的事物或实体，例如PC机、路由器、家具、房子、汽车，它们也有一个生存周期，这个生存周期就是使用寿命，即生产周期加上使用周期。

软件生存周期与开发模型有关。

### 1.4.2 软件生命周期内容

软件生命周期包括一下及格过程：

- 制定计划——解决什么问题，目标及其可  行性（技术、人员、财力、社会）
- 需求分析——做什么、验收标准
- 总体设计——怎么做
- 详细设计——具体怎么做
- 程序编写——实现
- 软件测试——保证软件质量
- 运行/维护——保证正常而可靠地运用

***



## 1.5 软件过程模型

### 1.5.1 瀑布模型

- 定义
  - 瀑布模型(Waterfall Model)又称流水式过程模型，它将软件开发过程模仿旅游景点的阶梯瀑布，由上向下一个阶梯一个阶梯地倾泻下来，最后进入一个风平浪尽的大湖，这个大湖就是软件企业的产品库。
- 本意
  - 根据软件生存周期由立项、需求、策划、设计、编程、测试、发布、  维护、退役等阶段组成，把每个阶段当作瀑布中的一个台阶，把软件生存过程比喻成瀑布中的流水。开发人员按照阶段开发，管理人员按照阶段管理。
- 特点
  1. 里程碑或基线驱动，或者说 文档驱动；
  2. 过程逆转性很差，或者说不可逆转。

- 选择模型的条件
  - **不是任何软件都可以采用瀑布模型的，选择瀑布模型，必须满足下列条件：**
  - 1. 在开发时间内需求没有或很少变化。
    2. 分析设计人员对应用领域很熟悉。
    3. 低风险项目（对目标、环境很熟悉）。
    4. 用户使用环境很稳定。
    5. 用户除提出需求以外，很少参与开发。

- 模型的缺点
  - 可维护性差，表现在：
    1. 由于逆转性很差，所以返工会造成重大损失。
    2. 由于文档驱动，错误的传递，会采取发散扩大的方式。

### 1.5.2 增量模型

- 定义
  - 增量模型将软件产品看作一组增量构件，每次设计、实现、集成、测试和交付一块构件，直到所有构件全部实现为止。
- 本意
  - 要开发一个大的软件系统，先开发其中的一个核心模块，后再开发其他模块，这样一个个模块地增加上去，直至整个系统开发完毕为止。
- 特点
  - 任务或功能模块驱动，可以分阶段提交产品；
  - 有多个任务单，这些多个任务单的集合，构成项目的一个总任务书(总用户需求报告)。
- 缺点
  - 若软件系统的组装和拆卸性不强，
  - 或开发人员全局把握水平不高（没有数据库设计专家进行系统集成），
  - 或者客户不同意分阶段提交产品，
  - 或者开发人员过剩，
  - 都不宜采用这种模型。

### 1.5.3 迭代模型

 **针对瀑布模型的缺陷，人们提出了迭代模型。**

- 本意
  - 迭代是产生可执行的产品发布的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代递增成长，最后形成最终软件系统或产品。

- 特点
  - 迭代或迭代循环驱动，每一次迭代或迭代循环，均要走完初始、精化、构建、移交4个阶段。
  - 面向对象方法和统一建模语言UML，尤其是面向对象的CASE工具Rose，适合于迭代模型。或者说，迭代模型很适合于面向对象的Rose工具。
- 缺点
  - 对项目组成员要求很高。
  - 必须掌握先进的开发工具。

### 1.5.4 原型模型

- 定义
  - 以某个软件原型为参照模型的开发方法，叫做原型法。
- 本意
  - 在初步需求分析之后，马上向客户展示一个软件产品原型，对客户进行培训，让客户试用，在试用中收集客户意见，修改原型，再让客户试用，反复循环几次，直到客户确认为止。
- 特点
  - 原型驱动。因此，开发者必须先有一个原型，至少要有一个原型的核心。
- 与迭代模型比较
  - 相同点是反复循环几次，直到客户确认为止。不同点是原型模型事先有一个展示性的产品原型，而迭代模型可能没有。
- 缺点
  - 因为事先有一个展示性的产品原型，所以在一定程度上，不利于开发人员的创新。





